# Protocol

## Messaging Topology
- The host exposes the authoritative server endpoint for all protocol sessions.
- The embedded intercom client connects to the host as a standard client and is the sole bridge to the physical intercom hardware.
- Home Assistant clients initiate outbound client sessions to the host when they need to control or monitor the intercom.

## Allowed Message Paths
- Home Assistant client → Host server → Embedded intercom client
- Embedded intercom client → Host server → Originating Home Assistant client
- Direct client ↔ client messaging is prohibited and should be rejected by the host.

## Connection Lifecycle
- All clients must begin by sending a `register` message: `{"type": "register", "role": "intercom"|"home_assistant", "client_id": "<string>", "token": "<optional>"}`.
- The host responds with `{"type": "registered", "status": "ok", "role": "<role>", "client_id": "<client_id>"}` or an error if registration fails.
- Only one intercom client may be registered at a time; subsequent intercom registrations are rejected.
- Registered clients should send a `close` control message or disconnect the transport to terminate the session.

## Message Envelopes
- Application payloads are UTF-8 JSON objects delimited by newlines on the TCP stream.
- Every message includes a `type` field and, when relevant, a `command_id` generated by the sender or assigned by the host.
- Hosts append `origin_id` when relaying commands to the intercom so responses can be correlated with a Home Assistant client.
- Error replies use `{"type": "error", "reason": "<string>", "details": {}}`.

## Command Flow (Home Assistant → Intercom)
- Home Assistant clients send `{"type": "command", "command": "<string>", "payload": {…}, "command_id": "<optional string>"}`.
- If a `command_id` is omitted, the host assigns a UUID and echoes it in the acknowledgment.
- The host relays the command to the intercom with `origin_id` identifying the requesting Home Assistant client.
- If the intercom is unavailable, the host responds with an error to the Home Assistant client.
- Successful submissions receive `{"type": "command_ack", "command_id": "<string>", "generated": true|false}` before the command is forwarded.

## Response Flow (Intercom → Home Assistant)
- The intercom replies with `{"type": "response", "command_id": "<string>", "status": "ok"|"error", "payload": {…}}`.
- The host forwards the response to the originating Home Assistant client based on `command_id`/`origin_id` tracking.
- Unmatched responses are reported back to the intercom as errors to detect protocol misuse.

## Event Flow (Intercom → Home Assistant)
- Intercom-originated events use `{"type": "event", "event": "<string>", "payload": {…}}`.
- The host fans out each event to all registered Home Assistant clients.
- The host may annotate events with server-generated metadata (e.g., timestamps) before forwarding.

## Intercom Responsibilities
- Maintain a persistent session with the host and be ready to process relayed commands immediately after registration.
- Reply to every command with a `response` message that echoes the `command_id`, returning `status` and any payload data required by Home Assistant.
- Generate unsolicited `event` messages for intercom-originated signals (e.g., doorbell pressed) so that Home Assistant clients stay informed.
- Treat host-sent `error` messages about outstanding commands (for example when a Home Assistant client disconnects) as a signal to stop further processing for that `command_id`.

## Audio Sessions
- Home Assistant clients request audio by issuing a `command` such as `start_audio`; the intercom responds with `{"type": "response", "status": "ok", "command_id": "…", "payload": {"stream_id": "<string>", "encoding": "pcm_s16le", "sample_rate": 16000, "channels": 1}}`.
- Audio is always bidirectional: once a stream is active, the host MUST accept audio frames from both parties and forward them to the other side.
- Audio frames use newline-delimited JSON: `{"type": "audio_frame", "stream_id": "<string>", "sequence": <int>, "encoding": "pcm_s16le", "sample_rate": 16000, "channels": 1, "data": "<base64>", "direction": "intercom_to_client"|"client_to_intercom"}`. The host overwrites `direction` according to the sender before relaying.
- Any party may stop a session by sending an appropriate control command (e.g., `stop_audio`) and responding `status: "ok"`; the host then tears down routing state and rejects further frames for that stream.
- Hosts drop frames when the destination is unavailable and may notify the sender with an `error` message referencing the `stream_id`.
